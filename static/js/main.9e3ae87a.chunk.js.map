{"version":3,"sources":["constants.js","components/helpers/gridModule.js","components/Grid.js","App.js","reportWebVitals.js","index.js"],"names":["DIRECTIONS","ALPHABET","ROWS","COLUMNS","copyGrid","grid","tempGrid","col","length","push","fillWithRandom","myGrid","y","x","constants","generateRandomNum","generateGrid","rows","columns","generateRandomDirection","directions","range","Number","isInteger","Math","floor","random","defaultWordList","Grid","useState","map","word","toUpperCase","wordList","setWordList","setGrid","setSolutionGrid","modal","setModal","loading","setLoading","theme","setTheme","maxWords","setMaxWords","minLength","setMinLength","useEffect","formSubmit","e","a","preventDefault","target","value","parseInt","fetch","then","response","json","data","myWords","wordlistFormatter","numOfWords","console","log","putWordsInGrid","toggleModal","catch","error","wordlist","finalWordList","result","filter","split","count","index","slice","concat","tempWordList","alert","attempts","putWordInGrid","table","debug","generateRandomPos","tempDirection","checkIfWordFits","direction","write","position","choices","Container","className","Button","onClick","title","Col","Row","letter","uuidv4","createWordSearchGrid","myWordList","xs","createWordList","href","Modal","isOpen","toggle","ModalHeader","Form","onSubmit","ModalBody","FormGroup","Label","for","Input","type","name","id","placeholder","defaultValue","ModalFooter","App","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.9e3ae87a.chunk.js","sourcesContent":["export const DIRECTIONS = [\"N\", \"E\", \"S\", \"W\", \"NE\", \"NW\", \"SE\", \"SW\"];\n\nexport const ALPHABET = [\n  \"A\",\n  \"B\",\n  \"C\",\n  \"D\",\n  \"E\",\n  \"F\",\n  \"G\",\n  \"H\",\n  \"I\",\n  \"J\",\n  \"K\",\n  \"L\",\n  \"M\",\n  \"N\",\n  \"O\",\n  \"P\",\n  \"Q\",\n  \"R\",\n  \"S\",\n  \"T\",\n  \"U\",\n  \"V\",\n  \"W\",\n  \"X\",\n  \"Y\",\n  \"Z\",\n];\n\nexport const ROWS = 15;\nexport const COLUMNS = 15;\n\nexport const API_PATH = \"https://api.datamuse.com/words\";\n","import * as constants from \"../../constants\";\n\nconst copyGrid = (grid) => {\n  let tempGrid = [];\n  for (let col = 0; col < grid.length; col++) {\n    tempGrid.push([...grid[col]]);\n  }\n  return tempGrid;\n};\n\nconst fillWithRandom = (myGrid) => {\n  //create a new copy of grid\n  let tempGrid = copyGrid(myGrid);\n\n  //run through tempGrid and change blank values\n  for (let y = 0; y < myGrid.length; y++) {\n    for (let x = 0; x < myGrid[0].length; x++) {\n      if (tempGrid[y][x] === 0) {\n        tempGrid[y][x] =\n          constants.ALPHABET[generateRandomNum(constants.ALPHABET.length)];\n      }\n    }\n  }\n\n  return tempGrid;\n};\n\nconst generateGrid = (rows, columns) => {\n  let tempGrid = [];\n  for (let x = 0; x < rows; x++) {\n    tempGrid.push([]);\n    for (let y = 0; y < columns; y++) {\n      tempGrid[x][y] = 0;\n    }\n  }\n  return tempGrid;\n};\n\nconst generateRandomDirection = (directions) => {\n  return directions[generateRandomNum(directions.length)];\n};\n\nconst generateRandomNum = (range = 0) => {\n  if (!Number.isInteger(range)) {\n    throw \"range must be a number\";\n  }\n  return Math.floor(Math.random() * range);\n};\n\nexport {\n  copyGrid,\n  fillWithRandom,\n  generateGrid,\n  generateRandomDirection,\n  generateRandomNum,\n};\n","import React, { useState, useEffect } from \"react\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport * as constants from \"../constants\";\n\nimport { Button, Container, Col, Row } from \"reactstrap\";\nimport { Modal, ModalHeader, ModalBody, ModalFooter } from \"reactstrap\";\nimport { Input, Form, FormGroup, Label } from \"reactstrap\";\n\nimport {\n  copyGrid,\n  fillWithRandom,\n  generateGrid,\n  generateRandomDirection,\n  generateRandomNum,\n} from \"./helpers/gridModule\";\n\nconst defaultWordList = [\n  \"pigeon\",\n  \"suppress\",\n  \"singer\",\n  \"casualty\",\n  \"curriculum\",\n  \"vacuum\",\n  \"jurisdiction\",\n  \"translate\",\n  \"organize\",\n  \"printer\",\n  \"impossible\",\n  \"mission\",\n];\n\nfunction Grid() {\n  const [wordList, setWordList] = useState(\n    defaultWordList.map((word) => word.toUpperCase())\n  );\n  const [grid, setGrid] = useState(null);\n  const [solutionGrid, setSolutionGrid] = useState([[]]);\n  const [modal, setModal] = useState(false);\n  const [loading, setLoading] = useState(false);\n\n  //for Form\n  const [theme, setTheme] = useState(\"\");\n  const [maxWords, setMaxWords] = useState(15);\n  const [minLength, setMinLength] = useState(5);\n\n  useEffect(() => {\n    setGrid(generateGrid(constants.ROWS, constants.COLUMNS));\n  }, []);\n\n  const generateCrosswordClicked = () => {\n    debugger;\n    putWordsInGrid(wordList);\n  };\n\n  const resetCrosswordClicked = () => {\n    generateGrid(constants.ROWS, constants.COLUMNS);\n  };\n\n  const formSubmit = async (e) => {\n    e.preventDefault();\n    let maxWords = e.target.maxWords.value || 10;\n    let theme = e.target.theme.value;\n    let minLength = parseInt(e.target.minLength.value);\n    setLoading(!loading);\n\n    setTheme(theme);\n    setMaxWords(maxWords);\n    setMinLength(minLength);\n\n    fetch(`${constants.API_PATH}?ml=${theme}&max=${1000}`)\n      .then((response) => response.json())\n      .then((data) => {\n        let myWords = data.map((word) => word.word);\n        myWords = wordlistFormatter(myWords, {\n          minLength,\n          numOfWords: maxWords,\n        });\n        console.log(myWords);\n        setWordList(myWords);\n        putWordsInGrid(myWords);\n        toggleModal();\n        setLoading(false);\n      })\n      .catch((error) => {\n        setLoading(false);\n        console.error(error);\n      });\n  };\n\n  const toggleModal = () => {\n    setModal(!modal);\n  };\n\n  const wordlistFormatter = (wordlist, { minLength = 0, numOfWords = 10 }) => {\n    let finalWordList = [];\n    let result = wordlist.filter(\n      (word) =>\n        word.split(\" \").length === 1 &&\n        word.length > minLength &&\n        word.length < constants.ROWS &&\n        word.length < constants.COLUMNS\n    );\n\n    for (\n      let count = 0;\n      count < numOfWords && result.length > numOfWords;\n      count++\n    ) {\n      let index = generateRandomNum(result.length);\n      finalWordList.push(result[index]);\n      result = result.slice(0, index).concat(result.slice(index + 1));\n    }\n\n    finalWordList = finalWordList.map((word) => word.toUpperCase());\n\n    return finalWordList;\n  };\n\n  const putWordsInGrid = (wordList, count = 0) => {\n    if (grid === null) {\n      console.log(\"WAIT\");\n      return;\n    }\n    let myGrid = generateGrid(constants.ROWS, constants.COLUMNS);\n    let tempWordList = [...wordList];\n    console.log(`running ${count} times`);\n\n    if (count > 100) {\n      alert(\n        `after ${count} tries unable to find a working crossword puzzle, please try with a different set of words`\n      );\n      return;\n    }\n\n    for (let word of tempWordList) {\n      let attempts = 0;\n      while (true) {\n        attempts++;\n        let result = putWordInGrid(myGrid, word);\n\n        if (attempts > constants.COLUMNS * constants.ROWS) {\n          console.log(\n            `Too many attempts. ${word} input failed after ${attempts} tries`\n          );\n          putWordsInGrid(wordList, count + 1);\n          throw `Too many attempts. ${word} input failed after ${attempts} tries`;\n        } else if (result) {\n          myGrid = result;\n          break;\n        }\n      }\n    }\n    setSolutionGrid(myGrid);\n    console.table(myGrid);\n    myGrid = fillWithRandom(myGrid);\n    console.table(myGrid);\n    setGrid(myGrid);\n  };\n\n  const putWordInGrid = (myGrid, word, debug = false) => {\n    let { x, y } = generateRandomPos(myGrid, word);\n    let tempDirection = generateRandomDirection(constants.DIRECTIONS);\n    let tempGrid = myGrid;\n    if (debug) {\n      console.log(`x is ${x}`);\n      console.log(`y is ${y}`);\n      console.log(`direction is ${tempDirection}`);\n      console.log(\n        `${word} fits ? ${checkIfWordFits(\n          tempGrid,\n          tempDirection,\n          wordList[0],\n          x,\n          y\n        )}`\n      );\n    }\n    if (checkIfWordFits(tempGrid, tempDirection, word, x, y)) {\n      return copyGrid(\n        checkIfWordFits(tempGrid, tempDirection, word, x, y, true)\n      );\n    }\n    return false;\n  };\n\n  const checkIfWordFits = (tempGrid, direction, word, x, y, write = false) => {\n    //checks if word fits and works in grid. returns false if it doesn't work.\n    //if in write mode (boolean) then write the word into grid and return grid\n    let result = true;\n    let myGrid = copyGrid(tempGrid);\n    switch (direction) {\n      case \"N\":\n        if (y - word.length < 0) {\n          return false;\n        }\n        for (let count = 0; count < word.length; count++) {\n          if (\n            myGrid[y - count][x] !== 0 &&\n            myGrid[y - count][x] !== word[count]\n          ) {\n            result = false;\n          }\n\n          if (write) {\n            myGrid[y - count][x] = word[count];\n          }\n        }\n        break;\n      case \"E\":\n        if (x + word.length >= constants.COLUMNS) {\n          return false;\n        }\n        for (let count = 0; count < word.length; count++) {\n          if (\n            myGrid[y][x + count] !== 0 &&\n            myGrid[y][x + count] !== word[count]\n          ) {\n            result = false;\n          }\n          if (write) {\n            myGrid[y][x + count] = word[count];\n          }\n        }\n        break;\n      case \"S\":\n        if (y + word.length >= constants.ROWS) {\n          return false;\n        }\n        for (let count = 0; count < word.length; count++) {\n          if (\n            myGrid[y + count][x] !== 0 &&\n            myGrid[y + count][x] !== word[count]\n          ) {\n            result = false;\n          }\n\n          if (write) {\n            myGrid[y + count][x] = word[count];\n          }\n        }\n        break;\n      case \"W\":\n        if (x - word.length < 0) {\n          return false;\n        }\n        for (let count = 0; count < word.length; count++) {\n          if (\n            myGrid[y][x - count] !== 0 &&\n            myGrid[y][x - count] !== word[count]\n          ) {\n            result = false;\n          }\n          if (write) {\n            myGrid[y][x - count] = word[count];\n          }\n        }\n        break;\n      case \"NE\":\n        if (y - word.length < 0 || x + word.length >= constants.COLUMNS) {\n          return false;\n        }\n        for (let count = 0; count < word.length; count++) {\n          if (\n            myGrid[y - count][x + count] !== 0 &&\n            myGrid[y - count][x + count] !== word[count]\n          ) {\n            result = false;\n          }\n          if (write) {\n            myGrid[y - count][x + count] = word[count];\n          }\n        }\n        break;\n      case \"NW\":\n        if (y - word.length < 0 || x - word.length < 0) {\n          return false;\n        }\n        for (let count = 0; count < word.length; count++) {\n          if (\n            myGrid[y - count][x - count] !== 0 &&\n            myGrid[y - count][x - count] !== word[count]\n          ) {\n            result = false;\n          }\n          if (write) {\n            myGrid[y - count][x - count] = word[count];\n          }\n        }\n        break;\n      case \"SE\":\n        if (\n          y + word.length >= constants.ROWS ||\n          x + word.length >= constants.COLUMNS\n        ) {\n          return false;\n        }\n        for (let count = 0; count < word.length; count++) {\n          if (\n            myGrid[y + count][x + count] !== 0 &&\n            myGrid[y + count][x + count] !== word[count]\n          ) {\n            result = false;\n          }\n          if (write) {\n            myGrid[y + count][x + count] = word[count];\n          }\n        }\n        break;\n      case \"SW\":\n        if (y + word.length >= constants.ROWS || x - word.length < 0) {\n          return false;\n        }\n        for (let count = 0; count < word.length; count++) {\n          if (\n            myGrid[y + count][x - count] !== 0 &&\n            myGrid[y + count][x - count] !== word[count]\n          ) {\n            result = false;\n          }\n          if (write) {\n            myGrid[y + count][x - count] = word[count];\n          }\n        }\n\n        break;\n      default:\n    }\n    if (!write) {\n      return result;\n    } else {\n      return copyGrid(myGrid);\n    }\n  };\n\n  const generateRandomPos = (myGrid, word) => {\n    let choices = [];\n    let position = {};\n\n    //create list of possible choices good candidate for useMemo();\n    for (let y = 0; y < constants.COLUMNS; y++) {\n      for (let x = 0; x < constants.ROWS; x++) {\n        if (myGrid[y][x] === 0 || myGrid[y][x] === word[0]) {\n          choices.push({ x, y });\n        }\n      }\n    }\n\n    position = { ...choices[generateRandomNum(choices.length)] };\n    return { ...position };\n  };\n\n  //react component creators\n  const createWordList = () => {\n    let myWordList = wordList.map((word) => (\n      <Col xs={3} className=\"text-center\" key={uuidv4()}>\n        {word}\n      </Col>\n    ));\n    return <Row>{myWordList}</Row>;\n  };\n\n  const createWordSearchGrid = () => {\n    if (grid === null) {\n      return;\n    }\n    return (\n      <Container className=\"wordsearch__container\">\n        {grid.map((col) => (\n          <Row key={uuidv4()}>\n            {col.map((letter) => (\n              <Col key={uuidv4()}>{letter}</Col>\n            ))}\n          </Row>\n        ))}\n      </Container>\n    );\n  };\n\n  if (loading) {\n    return <div>Loading</div>;\n  }\n\n  return (\n    <div>\n      <Container className=\"d-flex justify-content-center\">\n        <Button\n          onClick={generateCrosswordClicked}\n          title={\"mixes up the crossword again\"}\n        >\n          RE-GENERATE CROSSWORD\n        </Button>\n        <Button onClick={toggleModal}>Set Theme For Words</Button>\n      </Container>\n      <Container>\n        <Col className=\"text-center\">{theme.toUpperCase()}</Col>\n      </Container>\n      <Container>{createWordSearchGrid()}</Container>\n      <Container className=\"mt-5\">\n        <div className=\"text-center\">==========WORDLIST==========</div>\n        {createWordList()}\n        <div>\n          Words supplied by Datamuse{\" \"}\n          <a href=\"https://www.datamuse.com/api/\">\n            https://www.datamuse.com/api/\n          </a>\n          V.0.015\n        </div>\n      </Container>\n      <Modal isOpen={modal} toggle={toggleModal}>\n        <ModalHeader toggle={toggleModal}>Set your word theme</ModalHeader>\n        <Form onSubmit={(e) => formSubmit(e)}>\n          <ModalBody>\n            <FormGroup>\n              <Label for=\"word-theme\">Word Theme</Label>\n              <Input\n                type=\"text\"\n                name=\"theme\"\n                id=\"word-theme\"\n                placeholder=\"Insert Theme\"\n                defaultValue={theme}\n              />\n            </FormGroup>\n            <FormGroup>\n              <Label for=\"num_of_words\">Max Number of Words</Label>\n              <Input\n                type=\"number\"\n                name=\"maxWords\"\n                id=\"num_of_words\"\n                defaultValue={maxWords}\n              />\n            </FormGroup>\n            <FormGroup>\n              <Label for=\"length_of_words\">Minimum Word Length</Label>\n              <Input\n                type=\"number\"\n                name=\"minLength\"\n                id=\"length_of_words\"\n                defaultValue={minLength}\n              />\n            </FormGroup>\n          </ModalBody>\n          <ModalFooter>\n            <Button>Submit</Button>\n            <Button onClick={toggleModal}>Cancel</Button>\n          </ModalFooter>\n        </Form>\n      </Modal>\n    </div>\n  );\n}\n\nexport default Grid;\n","import React from \"react\";\nimport \"./App.css\";\n\nimport Grid from \"./components/Grid\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Grid />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}